## Запуск проекта 
Команда для запуска: `docker compose up --build`.

## Архитектура сервиса
В данном сервисе находится один модуль по работе с `tasks`.

Я постарался разбить модуль на 3 слоя: api(презентационный), application(или BLL в котором находится бизнес логика)
и infrastructure(или DAL-слой, который отвечает за получение данных).
- Соответ. аpi это rest-contoller и graphql-resolvers 
- application - вся наша бизнес логика 
- infrastructure - репозитории

И так же есть 2 сервиса-фасада(клиента) для удобной работы с mongo и rabbitMq

## Описание архитектуры RabbitMq
Этот брокер работает по принципу умный брокер - глупый потребитель. 
То есть вся логика, маршрутизация и тд, это in-box в брокере. Потребитель ни о чем не должен думать.

**Exchanges** - они же обменники, они принимают сообщения, которые паблишат продьюсеры. 
И далее обменник решает в какие очереди направить сообщения. Зависит это от типа обменника(каждый их них настроен на определенный тип маршрутизации)
и так же используют `routing key` сообщений для принятия решения в какую конкретно очередь или очереди направить сообщение.
Тут так же важно понимать, что нужно забаиндить очередь с обменником и ключом, что бы маршрутизация работала.

Я знаю про 3 обменника: 
- это `direct`(который по точному совпадению ключа отправляет сообщение в конкретную очередь)
- `fanout`, по сути рассылка и отправляет сообщения во все привязанные очереди
- `topic`, тоже самое что и direct, но ключ по шаблону, то есть точно совпадение не обязательно

**Очередь** - соответ. сюда попадают сообщения распределенные обменниками.
Сообщение хранится в очереди до тех пор пока консьюмер не отправит `ACK`, тогда сообщение будет удалено из очереди и далее возьмется следующие сообщение.

Есть еще такое понятие, как durable(долговечная очередь), когда сообщения сохраняются сразу на диск, по дефолту этого не происходит, как в какой-нибудь Kafka.

## Инструкции по настройке MongoDB
По сути настраивать тут много не приходилось: 
- Как зависимость поставил нативный `mongo` драйвер
- Добавил контейнер в docker-compose и из env прокинул только имя бд и соответ. сам хост в приложение для коннекта
- Далее создал клиент для удобной работы с бд(connect, получение коллекции) и далее композицией прокидываю коллекцию в нужный мне сервис(репозиторий)

## Инструкции по настройке RabbitMq
Тут соответ. план по настройке был схож c монгой: 
- Как зависимость поставил `amqplib`
- Добавил контейнер в docker-compose, прокинул в env имя обменника, очереди и ключ
- Создал клиент для работы с брокером, по аналогии добавил connect, publish и consume
- В контроллере и в резолверах делаю паблиш сообщения при создании и апдейте таски
- Так же создал отдельный класс `TaskConsume`, для подписки на сообщения и инициализирую подписку из `app.ts`

## Инструкции по настройке codegen graphql
- Как зависимость поставил `@graphql-codegen/cli`, `@graphql-codegen/typescript` и `@graphql-codegen/typescript-resolvers`
- Описал `codegen.yml` откуда брать схему, какие плагины юзать и тд 
- Добавил команду `"codegen": "graphql-codegen"` в package.json

## Ссылка на Postman
[Workspace](https://www.postman.com/gold-equinox-834629/workspace/g-media-testing)

## Сгенерированное LLM
- По итогу был сгенерирован `boilerplate` для быстрого начало работы 
- тесты для graphql
- и утилита `sanitizeObjectDeep` - по сути он получился универсальный, мне бы хватило только проверки типа на строку и выполнение санитайзинга. 
По сути мы проходимся по объекту и проверяем его типы, является ли свойство строкой, объектом, либо массивом, при этом мы игнорируем number, boolean и тд
И соответ. проверяем все данные в конкретном свойстве если это так же массив или объект, тогда по сути будет рекурсия и мы будет уходить в глубину.
- И так же ретраи для переподключения к rmq(не мог при старте проекта подключиться, так как rmq еще не запущен, при этом контейнер уже был поднят, но depends_on только от этого и защищает, поэтому пришлось делать retry на подключение), для быстроты реализации закинул в гпт, по сути дефолтная логика с ретраями

## Как сервис может взаимодейстовать с другими сервисами
- Синхронно(запрос-ответ): http, rpc 
- через брокеров
- через какой-нибудь gateway

## Как можно улучшить сервис
- Во-первых, для удобства работы я бы добавил lint-staged на pre-commit hook, что бы вручную не вызывать lint и prettier 
- Добавил бы `moongose`, так все таки с ним удобнее работать(описание схем, документа, метод `save`, который позволяет, работать с объектом, как в ОПП и тд)
- Сто процентов добавил бы `cqrs(command bus)`, для того что бы разбить сервисы по работе с бизнес логикой на отдельные `use-case`, потому-что когда сервис станет большой, его сложнее поддерживать, тестить, вносить какие-то изменения и тд
- Добавил бы интеграционные тесты для сервисов, репозиториев и тд. Написать unit-тесты на все утилиты 
- Стоит подумать над инициализацией модулей, сейчас он один и это `tasks`, как-будто бы `app.ts` не сильно захломлен, но обычно у нас не один модуль и я бы инкапсулировал бы все это в класс `Module(Имя_модуля)` и там бы инициализировал все провайдеры, и тд. И потом уже можно просто в `app` инитить сами модули, архитектурно мне кажется это более правильно
- Так же бы внедрил `паттерн outbox`, потому-что когда мы сохраним в бд, не факт что сообщение будет отправлено и соответ. получится не консистентность данных. Поэтому лучше сохранять сообщение в отдельную коллекцию, так мы будем уверены, что сообщени не будет потеряно и далее уже паблишить эти сообщение из бд
- Добавил бы `rate-limit` на запросы
